
import { Chess } from 'chess.js'
export { Chess }
export function initCheckers(){ const b=Array.from({length:8},()=>Array(8).fill(null)); for(let r=0;r<3;r++)for(let c=0;c<8;c++) if((r+c)%2===1) b[r][c]='b'; for(let r=5;r<8;r++)for(let c=0;c<8;c++) if((r+c)%2===1) b[r][c]='r'; return { board:b, turn:'r' } }
const inb=(r,c)=>r>=0&&r<8&&c>=0&&c<8, color=p=>p&&('rR'.includes(p)?'r':'b'), isK=p=>p&&('RB'.includes(p));
function movesFor(S,r,c){ const p=S.board[r][c]; if(!p) return {steps:[],jumps:[]}; const dirs=[]; if(isK(p)||color(p)==='r') dirs.push([-1,-1],[-1,1]); if(isK(p)||color(p)==='b') dirs.push([1,-1],[1,1]); const steps=[],jumps=[]; for(const [dr,dc] of dirs){ const nr=r+dr,nc=c+dc; if(inb(nr,nc)&&!S.board[nr][nc]) steps.push({to:[nr,nc]}); const jr=r+2*dr,jc=c+2*dc; if(inb(jr,jc)&&!S.board[jr][jc]&&S.board[nr][nc]&&color(S.board[nr][nc])!==color(p)) jumps.push({to:[jr,jc],cap:[nr,nc]}) } return {steps,jumps} }
function anyJump(S){ for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=S.board[r][c]; if(!p||color(p)!==S.turn) continue; if(movesFor(S,r,c).jumps.length) return true } return false }
export function applyCheckersMove(S, who, from, to){ if(S.turn!==who) return {ok:false}; const [fr,fc]=from,[tr,tc]=to; const p=S.board[fr][fc]; if(!p||color(p)!==who) return {ok:false}; const {steps,jumps}=movesFor(S,fr,fc); const mustJump=anyJump(S); const isStep=steps.some(m=>m.to[0]===tr&&m.to[1]===tc); const jump=jumps.find(m=>m.to[0]===tr&&m.to[1]===tc); if(mustJump&&!jump) return {ok:false}; if(jump){ S.board[tr][tc]=p; S.board[fr][fc]=null; const [cr,cc]=jump.cap; S.board[cr][cc]=null; if(who==='r'&&tr===0) S.board[tr][tc]='R'; if(who==='b'&&tr===7) S.board[tr][tc]='B'; const cont=movesFor(S,tr,tc).jumps; const canContinue=cont.length>0 && !((who==='r'&&tr===0)||(who==='b'&&tr===7)); if(canContinue) return {ok:true,state:S,more:true} } else if(isStep){ S.board[tr][tc]=p; S.board[fr][fc]=null; if(who==='r'&&tr===0) S.board[tr][tc]='R'; if(who==='b'&&tr===7) S.board[tr][tc]='B' } else return {ok:false}; S.turn=(S.turn==='r'?'b':'r'); let hasr=false,hasb=false; for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const t=S.board[r][c]; if(t){ if(color(t)==='r')hasr=true; else hasb=true } } const winner=!hasb?'A':(!hasr?'B':null); return {ok:true,state:S,winner} }
export function initWhot(){ const suits=['★','■','▲','●']; const nums=[1,2,3,4,5,6,7,8,9,10,11,12,13,14]; let deck=[]; for(const s of suits) for(const n of nums) deck.push({s,n}); for(let i=0;i<4;i++) deck.push({s:'WHOT',n:20}); deck=shuffle(deck); const A=deck.splice(0,5), B=deck.splice(0,5), pile=[deck.splice(0,1)[0]]; return { deck,pile,A,B,turn:'A',call:null,deadline: Date.now()+30000 } }
function canPlay(top,card,call){ if(card.s==='WHOT') return true; if(call) return card.s===call; return card.s===top.s||card.n===top.n }
export function whotTickTimeout(S){ if(Date.now()>S.deadline){ whotDraw(S,S.turn) } }
export function whotPlay(S,side,index,calledSuit){ whotTickTimeout(S); if(S.turn!==side) return {ok:false}; const hand=(side==='A')?S.A:S.B; const card=hand[index]; if(!card) return {ok:false}; const top=S.pile[S.pile.length-1]; if(!canPlay(top,card,S.call)) return {ok:false}; hand.splice(index,1); S.pile.push(card); let extra=false,skip=false; if(card.s==='WHOT'){ S.call=calledSuit||'★' } else { S.call=null; if(card.n===5) extra=true; if(card.n===2) skip=true } const winner=hand.length===0?side:null; if(!winner){ S.turn=extra?side:(side==='A'?'B':'A'); S.deadline=Date.now()+30000 } return {ok:true,state:S,winner} }
export function whotDraw(S,side){ if(S.turn!==side) return {ok:false}; if(!S.deck.length){ const last=S.pile.pop(); S.deck=shuffle(S.pile); S.pile=[last] } const card=S.deck.shift(); if(!card) return {ok:false}; (side==='A'?S.A:S.B).push(card); S.turn=(side==='A'?'B':'A'); S.deadline=Date.now()+30000; return {ok:true,state:S} }
export function initLudo(){ const track=28,homeLen=4; const tokens=()=>[{pos:-1},{pos:-1},{pos:-1},{pos:-1}]; const safe=[0,7,14,21]; return { track,homeLen,safe,A:tokens(),B:tokens(),turn:'A',die:null } }
export function ludoRoll(S){ S.die=1+Math.floor(Math.random()*6); return S.die }
export function ludoMove(S,side,idx){ if(S.turn!==side||!Number.isInteger(idx)||idx<0||idx>3) return {ok:false}; const die=S.die; if(!die) return {ok:false}; const me=S[side], opp=S[side==='A'?'B':'A']; const track=S.track, home=S.homeLen, safe=S.safe; const t=me[idx]; const isBlockade=(pos)=> me.filter(x=>x.pos===pos).length>=2; if(t.pos===-1){ if(die===6 && !isBlockade(0)){ t.pos=0; S.die=null; return post() } return {ok:false} } let target=t.pos+die; if(t.pos<track){ if(target<track){ if(isBlockade(target)) return {ok:false}; if(!safe.includes(target)){ for(const o of opp){ if(o.pos===target){ o.pos=-1 } } } t.pos=target; S.die=null; return post() } else { const into=target-track+1; if(into<=home){ t.pos=track+into-1; S.die=null; return post() } return {ok:false} } } else { const newPos=t.pos+die; if(newPos<=track+home-1){ t.pos=newPos; S.die=null; return post() } return {ok:false} } function post(){ if(die!==6) S.turn=(side==='A'?'B':'A'); S.die=null; const done=me.every(tok=>tok.pos>=track+home-1); return {ok:true,state:S,winner: done?side:null} } }
export function archeryScore(seed, shot){ const s=parseInt(seed.slice(0,2),16)%10; const center=0.45+(s-5)*0.005; const dist=Math.abs(Math.max(0,Math.min(1,shot))-center); return Math.max(0, Math.round(10 - dist*20)) }
export function poolShotSuccess(power){ const p=Math.max(0,Math.min(1,power||0)); return Math.random() < (0.2 + Math.max(0,1-Math.abs(p-0.7)*2)*0.6) }
function shuffle(a){ const b=[...a]; for(let i=b.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]] } return b }
